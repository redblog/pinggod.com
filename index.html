<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PINGGOD</title><meta name="description" content="三年不翅，将以长羽翼；不飞不鸣，将以观民则。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/开发者必看的技术站点/" class="post-title-link">WEB 开发者必看的技术站点</a></h2><div class="post-meta"><div class="post-time">Dec 31, 2015</div></div><div class="post-content"><blockquote>
<p>本文总结自 Quora 上的一个问答：<a href="https://www.quora.com/What-are-the-top-10-websites-a-web-developer-must-see">What are the top 10 websites a web developer must see</a>。</p>
</blockquote>
<p>读专业书、看教程视频、浏览技术博客、参加讲座分享……这些提高技能的途径各有优劣，相比较而言，博客或者说技术网站可以最快接触前沿技术、分享技术实践，所以，除了依赖谷歌反馈的词条，我们还可以主动收集一些优秀的技术站点，便于自己了解、参与和实践业界最活跃的技术。</p></div><a href="2015/开发者必看的技术站点/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/mac-tool-kit/" class="post-title-link">Mac Tool Kit</a></h2><div class="post-meta"><div class="post-time">Dec 26, 2015</div></div><div class="post-content"><p>这会是一篇持续更新的文章，用于记录我在 mac 中常用的开发工具。过去的一年（2015）里，我使用 mac 作为开发的主力平台，在上面折腾过各类软件，以实现最高的开发效率和最舒适的开发环境。一切都是为了开发成果服务，脱离结果强调过程不是我支持的态度，简而言之，这些都是一些增益技巧。</p>
<p>文中工具的排序规则（核心是优先安装具有依赖关系的软件）：</p>
<ol>
<li>从常用工具中随机选择一个工具作为 random seed</li>
<li>根据 random seed 的配置过程进行上溯，上溯到的目标工具排在 random seed 之前</li>
<li>如果上溯到的系统工具不常用，以常用工具替换，比如 chrome 替换 safari</li>
<li>random seed 可组合使用的工具排在 random seed 之后</li>
<li>random seed 中包含的插件在 random seed 中以列表的形式列出</li>
<li>每次接触新工具，将 random seed 设为该工具，循环执行 2、3、4 过程</li>
<li>其他工具根据肌肉对键盘的非条件反射随机排列</li>
</ol>
<p><img src="/img/mac-tool-kit.png" alt="mac tool kit 排列方法 2015-12-27.png"></p></div><a href="2015/mac-tool-kit/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/ES2015/" class="post-title-link">ES2015</a></h2><div class="post-meta"><div class="post-time">Dec 15, 2015</div></div><div class="post-content"><p>ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。</p>
<p>虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：<a href="http://kangax.github.io/compat-table/es6/">ES2015 兼容性列表</a>。</p></div><a href="2015/ES2015/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/求值策略/" class="post-title-link">求值策略</a></h2><div class="post-meta"><div class="post-time">Dec 10, 2015</div></div><div class="post-content"><blockquote>
<p>须知参差多态乃是幸福本源。</p>
</blockquote>
<p>求值策略所要解决的问题是：何时求值。之所以要控制求值的时间，往往是出于对内存占用和执行效率的考虑。在维基百科的求值策略词条中，列出了五种求值策略：</p>
<ul>
<li>预先求值，表达式绑定到变量时，立即求值并附加给变量</li>
<li>延迟求值，表达式绑定到变量后，并不求值，直到变量被调用时才求值</li>
<li>局部求值，又称柯里化</li>
<li>分布求值，map/reduce，典型应用是分布式计算</li>
<li>短路求值，与 (&amp;&amp;) 、或 (||) 逻辑运算</li>
</ul>
<p>顾名思义，预先求值和延迟求值是一对对立的求值策略。在下面的 js 代码段中，声明了变量 x，x 赋值后又被调用了三次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span> + <span class="number">3</span> * (<span class="number">1</span> + <span class="number">5</span> ^ <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">func(x);</span><br></pre></td></tr></table></figure></div><a href="2015/求值策略/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/inline-and-absolute/" class="post-title-link">Inline* and Absolute</a></h2><div class="post-meta"><div class="post-time">Dec 6, 2015</div></div><div class="post-content"><p>在一个容器中，所有元素都是 inline / inline-block 类型，此时可以使用 absolute + margin 的方式实现相对定位，而且相对定位的位置就是脱离文档流之前的位置。</p>
<p><img src="/img/inline-and-absolute.png" alt="absolute and margin"></p></div><a href="2015/inline-and-absolute/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/Pug/" class="post-title-link">Pug</a></h2><div class="post-meta"><div class="post-time">Dec 3, 2015</div></div><div class="post-content"><div class="tip"><br>    由于商标版权问题，Jade 已经改名为了 Pug，详见 <a href="https://github.com/pugjs/jade/issues/2184">issue</a>。<br></div>

<p>如果你熟悉 Sublime Text 和 Emmet 的组合，那么 Pug 也会是你的菜。Pug 类似于 Python，都采用了对缩进敏感的语法形式，比如下面这段代码创建了一个无序列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ul(<span class="class"><span class="keyword">class</span></span>=<span class="string">"inline"</span>)</span><br><span class="line">    li  Item C</span><br><span class="line">    li  Item A</span><br><span class="line">    li  Item B</span><br></pre></td></tr></table></figure></div><a href="2015/Pug/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/CSS-Flexbox/" class="post-title-link">CSS Flexbox</a></h2><div class="post-meta"><div class="post-time">Dec 2, 2015</div></div><div class="post-content"><p>如果你正在学习使用 CSS 布局，推荐来 <a href="http://zh.learnlayout.com/toc.html">learnlayout</a> 了解一下这些年前端所用到的各类布局手法。这里之所以使用“手法”一词，意指其中多少有些偏激取巧，比如使用浮动（float）来定位、使用 margin 来伸缩空间等等。</p>
<p>float、margin 本不应该用于布局，只是囿于早期的 CSS 布局模块发展缓慢且不合时宜，促使开发者另辟蹊径，借助其他样式来模拟布局效果。最近几年随着浏览器对布局模块的支持度越来越高，Flexible Box Layout（Flexbox）、Grid Layout、Multiple Column Layout 也逐渐为开发者所接受，其中以 Flexbox 的兼容性最好，拥护者也随之水涨船高。</p>
<p>就个人感受而言，未来的布局方式会归纳为两类：一类是纯粹使用浏览器兼容性高的布局模块，比如 Flexbox，这也是未来的发展趋势；另一类是使用预处理器或者框架自定义的布局模块，这只是目前的缓兵过渡之计。</p></div><a href="2015/CSS-Flexbox/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/void-and-undefined/" class="post-title-link">Void and Undefined</a></h2><div class="post-meta"><div class="post-time">Nov 30, 2015</div></div><div class="post-content"><p>一直以来，<code>undefined</code> 都不是 JavaScript 的关键字或保留字，这意味着我们可以修改 window.undefined 的值。由于 undefined 会被频繁调用作为比较运算的操作数，所以在 ES5 规范之后，window.undefined 被定义为不可写、不可配置的属性。常见的 undefined 列述如下:</p>
<ul>
<li>变量声明后未赋值，则变量会被自动赋值为 undefined</li>
<li>函数中定义了一些形参，如果传入的实参少于预定义的形参，那么有一些形参就会匹配不到实参，继而会被自动赋值为 undefined</li>
<li>没有返回值的函数，默认返回 undefined</li>
</ul>
<p><code>void (expression)</code>，void 作为一个运算符，无论表达式的内容是什么，只要跟在 void 之后都会被调用执行，执行完毕后 void 操作符返回 undefined。简而言之，使用 void 运算符有三种用处：生成 undefined；让函数立即执行；充当 <code>javascript:</code> 协议的 URI。</p></div><a href="2015/void-and-undefined/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/React-组件间的消息传递/" class="post-title-link">React 组件间的消息传递</a></h2><div class="post-meta"><div class="post-time">Nov 28, 2015</div></div><div class="post-content"><p>当我们封装了可复用的组件之后，用来驱动组件渲染内容的数据就变得愈发灵活，组件之间数据通信的问题就摆在了桌面上。React 组件间的消息传递主要集中于三种关系中：</p>
<ul>
<li>从父组件向子组件的消息传递</li>
<li>从子组件向父组件的消息传递</li>
<li>无关联组件之间的消息传递</li>
</ul>
<p>前两种关系都可以使用 React 内建的 <code>this.props</code> 对象来处理：</p>
<p><img src="/img/react-component-comunication.png" alt="父子组件之间的消息传递"></p></div><a href="2015/React-组件间的消息传递/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/React-组件的生命周期/" class="post-title-link">React 组件的生命周期</a></h2><div class="post-meta"><div class="post-time">Nov 23, 2015</div></div><div class="post-content"><p>在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：</p>
<p><img src="/img/react-lifecycle.png" alt="React 组件的生命周期"></p></div><a href="2015/React-组件的生命周期/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>