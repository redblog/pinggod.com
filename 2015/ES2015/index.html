<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ES2015 · PINGGOD</title><meta name="description" content="ES2015 - Sean Sun"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">ES2015</h1><div class="post-meta"><div class="post-time">Dec 15, 2015</div></div><div class="post-content"><p>ES2015 是最新的 JavaScript 语法规范，也是前端工程化高速发展所催化出的产物。JS 的不成熟一直为人诟病，前端的高速发展又离不开 JS，所以这次激进的变革显得十分必要。</p>
<p>虽然 ES2015 规范发布了，但是要原生的运行在浏览器上还是受到诸多因素的肘制，比如各版本浏览器的用户量、浏览器厂商对新特性的支持度等等。目前的权宜之计是使用 Babel 之类的编译器将 ES2015 代码转换为 ES5，所以下文中的 ES2015 代码也暂时以 Babel 的解析结果为准。各版本浏览器对 ES2015（ES6）、ES2016（ES7）的支持度可以参考这里：<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES2015 兼容性列表</a>。</p>
<a id="more"></a>
<h2 id="块级作用域和变量声明">块级作用域和变量声明</h2><p>ES6 新增了以花括号 <code>{}</code> 为标志的块级作用域，用以增强代码的稳健性。在 ES6 之前，JS 中只有全局作用域和函数作用域（eval 作用域？我没用过），这种设计有多种弊端，比如最常见的循环变量泄露为全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>虽然循环结束了，但是 i 的值在全局作用域内仍然有效，进而形成了一系列的错误。对于这种错误，最常见的处理方式是使用立即执行函数（Immediately-Invoked Function Expression）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>这里用到的立即执行函数实际上是将<a href="http://pinggod.com/2015/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/">求值策略</a>从延迟求值转变为了预先求值，但仍然不够优雅和健壮。在 ES2015 中，通过使用 <code>let</code> 来声明循环变量同样可以解决这个问题，而且方式更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]());</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 和 <code>const</code> 是 ES2015 新增的变量声明指令：let 用来声明变量，const 用来声明常量。当使用 let 和 const 声明变量时，所声明的变量只在当前的块级作用域内有效，这一点是与 var 的本质差别，也是上述代码生效的基础。对于 var 时代的各种诡异特性，现在 let 和 const 做了一些修改：</p>
<ul>
<li>let 和 const 声明的变量不存在变量提升</li>
<li>let 和 const 声明的变量不允许在同一作用域内重复声明多次</li>
<li>let 和 const 声明的变量必须先声明后使用，否则抛出 ReferenceError</li>
</ul>
<p>从块级作用域的开始到 let 和 const 变量声明的区域被称为临时死区（temporal dead zone），意指此处调用未声明的 let 和 const 变量一定报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    temp = <span class="string">'abc'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// blablablabla</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该行代码之前都属于变量 temp 的 temporal dead zone</span></span><br><span class="line">    <span class="comment">// 意指在此之前不可使用变量 temp</span></span><br><span class="line">    <span class="keyword">let</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip"><br>    在浏览器环境下，使用 var 声明的全局变量都会挂载在全局对象 window 下面。ES 2015 规定，使用 var 和 function 声明的全局变量仍然挂载在全局对象下面，但是 let、const 和 class 声明的全局变量则不属于全局对象。<br></div>


<h2 id="解构赋值">解构赋值</h2><p>解构赋值是 ES2015 提供的一种语法糖操作，常用于简化对数组和对象的数据提取。可以使用解构赋值的数据类型包括：</p>
<ul>
<li>对象</li>
<li>字符串</li>
<li>数值和布尔值（自动转换为对象，然后调用 toString() ）</li>
<li>数组，以及具有 Iterator 结构的数据结构，比如 Set 等</li>
</ul>
<p>下面我们通过一些实例来看一下解构赋值的使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 交换两个数的值</span></span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取 JSON 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">JSON</span> = &#123;</span><br><span class="line">    id: <span class="number">12345</span>,</span><br><span class="line">    status: <span class="string">'OK'</span>,</span><br><span class="line">    data: [<span class="number">123</span>, <span class="number">456</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; id, status, data &#125; = <span class="built_in">JSON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按需加载模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; Route, DefaultRoute, HistoryLocation &#125; = ReactRouter; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从函数返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStyle</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> font = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> border = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> position = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> &#123; font, border, position &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    font: fontStyle,</span><br><span class="line">    border: borderStyle,</span><br><span class="line">    position: positionStyle</span><br><span class="line">&#125; = handleStyle();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解构赋值可以以 <code>[x = &#39;0&#39;] = [y]</code> 的形式设置默认值，当 y 不存在时，x 的值就是 0；如果 y 不存在且没有设置默认值，则会被自动赋值为 undefined。</p>
</blockquote>
<h2 id="字符串">字符串</h2><p>在 JS 内部，字符以 16 位 2 字节的格式存储，这种表示法的范围限制为 \u0000-\uFFFF，对于超出范围的字符（\u20BB7），会被解析为两个字符四个字节（\u20BB\u0007）。ES2015 增强了对 Unicode 的支持，提出了一种新的字符表示方法：\u{20BB7}。</p>
<p>对于新的字符表示形式 <code>\u{codePoint}</code>，传统的字符串方法已经不适用了，所以 ES2015 提出了一系列新的方法来替代，它们可以正确识别编码大于 \uFFFF 的字符：</p>
<ul>
<li>at()，对应 charAt()，返回指定位置的字符</li>
<li>codePointAt()，对应 charCodeAt()，返回指定位置字符的编码</li>
<li>String.fromCodePoint()，对应 String.fromCharCode()，返回指定编码所对应的字符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u20BB7'</span></span><br><span class="line"><span class="comment">// =&gt; '₻7'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span></span><br><span class="line"><span class="comment">// =&gt; '𠮷'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.charAt(<span class="number">0</span>)   </span><br><span class="line"><span class="comment">// =&gt; '�'</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.at(<span class="number">0</span>)       </span><br><span class="line"><span class="comment">// =&gt; "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; 20BB7</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.codePointAt(<span class="number">1</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; DFB7</span></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; DFB7</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a\u&#123;20BB7&#125;b'</span>.length</span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'a\u&#123;20BB7&#125;b'</span>).length</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>ES2015 规范中规定字符串实现了 Iterator 接口，用于 for … of 遍历，此外，增加了一些工具类方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串开头</span></span><br><span class="line">str.startsWith(<span class="string">'abc'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否包含参数字符串</span></span><br><span class="line">str.includes(<span class="string">'def'</span>);</span><br><span class="line"><span class="comment">// 判断字符串 str 是否以参数字符串结尾</span></span><br><span class="line">str.endsWith(<span class="string">'ghi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成重复字符串</span></span><br><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; 'xxx'</span></span><br></pre></td></tr></table></figure>
<p>字符串的另一个强力扩展是：模板字符串和标签模板。模板字符串（template string）类似于其他编程语言中的字符串插值，以反引号（`）为标志，字符串中的插值部分使用 <code>${}</code> 包裹：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// =&gt; '3 + 4 = 7'</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数的函数名之后紧跟一个模板字符串，那么这个函数就会被用来处理这个模板字符串，这个功能被称为<code>标签模板（tagged template）</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是一个数组</span></span><br><span class="line"><span class="comment">// 数组的元素是被插值部分分隔的字符串</span></span><br><span class="line"><span class="comment">// 第二个及以后的参数代表模板字符串中插值部分的值</span></span><br><span class="line"><span class="comment">// 可以使用参数扩展语法将其包裹到一个变量中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(strs);</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// =&gt; [""," + "," = ",""]</span></span><br><span class="line"><span class="comment">// =&gt; [3,4,7]</span></span><br></pre></td></tr></table></figure>
<p>标签模板的一个实际运用就是过滤 HTML 字符串，提高安全性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeHTML</span> (<span class="params">strs, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    strs.forEach( (str, index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="built_in">String</span>(values[index]);</span><br><span class="line"></span><br><span class="line">        result += str;</span><br><span class="line">        <span class="keyword">if</span> ( temp ) &#123;</span><br><span class="line">            result += temp.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">                          .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'$lt;'</span>)</span><br><span class="line">                          .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gc;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="string">'&lt;html tag&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> msg = safeHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;user&#125;</span> has sent you a msg.&lt;/p&gt;`</span>;</span><br><span class="line"><span class="comment">// =&gt; &lt;p&gt;$lt;html tag&amp;gc; has sent you a msg.&lt;/p&gt;undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="数值">数值</h2><p>数值部分，一个是在 Number 对象上丰富了一些工具函数</p>
<ul>
<li>Nubmer.isNaN()</li>
<li>Number.isFinite()</li>
<li>Number.parseInt()</li>
<li>Nubmer.parseFloat()</li>
<li>Nnmber.isInteger()</li>
<li>Number.EPSILON，极小量常量，在数值比对时，如果小于极小量，则判断两数相等</li>
<li>Number.isSafeInteger()，安全范围指（-2^53，2^53）</li>
<li>Number.MAX_SAFE_INTEGER</li>
<li>Number.MIN_SAFE_INTEGER</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseFloat === <span class="built_in">Number</span>.parseFloat</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt === <span class="built_in">Number</span>.parseInt</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// =&gt; 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span> &lt; <span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>二是在 Math 对象上扩展了一些数学函数：</p>
<ul>
<li>Math.trunc()，去除浮点数的小数部分</li>
<li>Math.sign()，判断数值是正数、负数还是零</li>
<li>Math.cbrt()，计算一个数值的立方根</li>
<li>Math.clz32()，返回一个数值的 32 位无符号整数形式前前导零的个数</li>
<li>Math.imul()</li>
<li>Math.fround()</li>
<li>Math.hypot()</li>
<li>Math.expn1()</li>
<li>Math.log1p()</li>
<li>Math.log10()</li>
<li>Math.log2()</li>
<li>Math.sinh()</li>
<li>Math.cosh()</li>
<li>Math.tanh()</li>
<li>Math.asinh()</li>
<li>Math.acosh()</li>
<li>Math.atanh()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">3.1415926</span>);</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">16</span>)</span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2><p>在函数中，参数对象 arguments 是一个具有 length 属性的对象，这一类对象被称为类数组对象（array-like object），常见的类数组对象包括 arguments 对象和 DOM 操作返回的 NodeList 集合，对于此类类数组对象，我们往往希望可以将其转换为数组，方便调用数组的方法对数据进行处理。在 ES6 中有一个方法专门用于转换类数组对象为真正的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="string">'0'</span>: <span class="string">'a'</span>, length: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// =&gt; [ "a", undefined ]</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，对象中的 length 属性确定了转换后数组的长度，索引不匹配的位置返回 undefined，此外 Array.from() 还接受第二个参数，用于对 obj 数据进行 map 处理。此外，对于 ES6 新增的 Set 和 Map 数据结构，也可以使用 Array.from() 转换为数组。</p>
<p>在前面我们遇到了字符串编码大于 \uFFFF 时，字符长度会被误判的问题，这种情况下可以使用 Array.from() 将字符串转换为数组，获取数组的长度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.length</span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">"𠮷"</span>).length;</span><br><span class="line"><span class="comment">// =&gt;  1</span></span><br></pre></td></tr></table></figure>
<p>数组的构造函数 Array() 一直存在行为不确定的问题（一个参数表示新建数组长度，多个参数表示新建数组的组成元素），对此 ES6 提出了 Array.of() 方法来构建数组。Array.of() 方法接收任意多个参数，这些参数就是返回数组的元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">'a'</span>, &#123;&#125;, [], <span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// =&gt; [ 1, "a", Object, Array[0], Symbol() ]</span></span><br></pre></td></tr></table></figure>
<p>在众多的数组方法中，有那么一类方法非常值得警惕，这类方法的危险性在于，它们可以修改数组自身的数据，常见方法有：<strong>pop() / push() / shift() / unshift() / reverse() / sort() / splice()</strong>。在 ES6 中也存在两个可以修改数组自身的方法：copyWithin() 和 fill()：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copyWithin(arrayStart[, copyStart, copyEnd])</span></span><br><span class="line"><span class="comment">// arrayStart: 从数组的该位置开始修改数据</span></span><br><span class="line"><span class="comment">// copyStart: 从数组的该位置开始取数据</span></span><br><span class="line"><span class="comment">// copyEnd: 从数组的该位置停止取数据</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; [ 4, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fill(num, start, end) 方法可以用于数据重置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].fill(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// =&gt; [ 1, 2, 3, 0, 5 ]</span></span><br></pre></td></tr></table></figure>
<p>新增的 find() 和 some() 类似，都需要一个回调函数对遍历到的元素进行判断，不同点在于，find() 返回符合条件的第一个值，some() 则是在遇到复合条件的元素时返回 true；另一个新增的 findIndex() 与 indexOf() 类似，用于在数组中查找特定值的索引，不同之处在于 findIndex() 接收一个回调函数，indexOf() 接收的是一个值，此外，findIndex() 配合 Object.is 可以发现 NaN：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>].indexOf(y =&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// =&gt; -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>].findIndex(y =&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以使用 includes() 方法来判断是否存在：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>对于数组的遍历，ES6 提供了更精细的方法 entries() / keys() / values()，分别是对键值对、键和值的遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 'a'</span></span><br><span class="line"><span class="comment">// =&gt; 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [ 0, "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 1, "b" ]</span></span><br></pre></td></tr></table></figure>
<p>最后，值得一提的是，babel 编译已经支持了数组推导式（ES7），这一推到式在 Haskell 和 python 中都有实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> years = [ <span class="number">1954</span>, <span class="number">1974</span>, <span class="number">1990</span>, <span class="number">2006</span>, <span class="number">2010</span>, <span class="number">2014</span> ];</span><br><span class="line"><span class="keyword">const</span> array = [ <span class="keyword">for</span> ( year <span class="keyword">of</span> years ) <span class="keyword">if</span> ( year &gt; <span class="number">1990</span> ) <span class="keyword">if</span> ( year &lt; <span class="number">2014</span> ) year ];</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">// =&gt; [ 2006, 2010 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2><p>先看一个示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"> x, y = 2, ...z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`x = <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`y = <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`z = <span class="subst">$&#123;z&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// =&gt; x = 1</span></span><br><span class="line"><span class="comment">// =&gt; y = 2</span></span><br><span class="line"><span class="comment">// =&gt; z = 2,3,5,8,13</span></span><br><span class="line"></span><br><span class="line">consoel.log(f.length);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>这个示例中聚合了很多 ES6 在函数方面的特性，第一处是 <code>y = 2</code>，这种形式定义了函数参数的默认值，所以这里的 y 相当于一个默认值参数；第二处是 <code>...z</code>，这里的 z 被称为 rest 参数，用于存放函数中多余的参数，该参数往往可以用来替代 arguments 对象，因为它天生就是数组类型；第三处是传参时的 undefined，如果我们想跳过某个参数，需要显示的将该参数赋值为 undefined，使用 null 的话没有效果；第四处就是 func.length，这里的 length 表示普通参数的数量，如果我们测试 arugments.length，会发现结果为 7，因为这里的 arguments.length 表示的是传入参数的数量；最后一处不是很明显，但是很重要，就是普通参数、默认值参数和 rest 参数的位置顺序。</p>
<p>进一步还可以配合对象解构来传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>, &#123;&#125;);</span><br><span class="line"><span class="comment">// =&gt; 'GET'</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>);</span><br><span class="line"><span class="comment">// =&gt; Cannot read property 'body' of undefined</span></span><br></pre></td></tr></table></figure>
<p>第二个 fetch 的问题在于不能省略第二个参数，如果要省略参数，可以设置双重默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125; </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://meituan.com'</span>);</span><br><span class="line"><span class="comment">// =&gt; 'GET'</span></span><br></pre></td></tr></table></figure>
<p>rest 参数 <code>...rest</code> 用于将参数打包成数组，通过扩展运算符 <code>...</code>，可以执行逆运算，将数组（babel 也支持对类数对象的转换）转换为以分号分隔的参数序列：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">0</span>, ...rest, <span class="number">21</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>);</span><br><span class="line"><span class="comment">// =&gt; [0,1,1,2,3,5,8,13,21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际运用</span></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p>接下来是比较亮眼的箭头函数<code>=&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">k, v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; k: v &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> f = (k, v) =&gt; ( &#123; k: v &#125; );</span><br></pre></td></tr></table></figure>
<p>看到箭头函数的第一感官就是：简洁。另一个重要的点在于，箭头函数绑定了 this 对象，其特点如下：</p>
<ol>
<li>this 对象的指向是可变，但在箭头函数中，它固定的志向定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以用于构造函数</li>
<li>不可以使用 arguments 对象，可以使用 rest 参数代替</li>
<li>不能用作 Generator 函数，所以不能使用 yield 命令</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call( &#123; id: <span class="number">42</span> &#125; );</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p>之所以 this 的指向是固定的，根据 babel 的实现来说，是因为箭头函数内并没有 this 对象，无论箭头函数嵌套多少层，它都是指向定时所在的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo.call( &#123; id: <span class="number">42</span> &#125; )()()();</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel 编译结果</span></span><br><span class="line"><span class="pi">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"id:"</span>, _this.id);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123; id: <span class="number">42</span> &#125;)()()();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES7 提出了函数绑定的概念，使用双冒号 <code>::</code> 来替代 call/apply/bind 的调用，目前 babel 已经支持该特性，双冒号左侧是一个对象，右侧是一个函数，实现以左边对象为上下文对象的右边函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; id: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj::f();</span><br><span class="line"><span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最后，讲讲尾函数调用的优化问题。在函数式编程中，如果某个函数的最后一步是函数调用过程，那么这一过程就成为尾调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数并不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面示例相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    g(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用过程是不断入栈出栈的过程，由于尾调用是最后一步操作，所以不需要保存外层函数的调用，这被称为尾调用优化，即只保留内层函数的调用帧，这种优化的好处是如果函数都是尾调用，那么就可以优化到每次尾调用都只保留一层调用，大大节省内存，这就是尾调用优化的意义。</p>
<p>函数调用自身的过程，成为递归，如果尾调用自身，则称为尾递归。下面是一个阶乘函数，没有使用尾递归，最多需要保存 n 个调用记录，复杂度为 O(n)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尾递归改写，只保留一个调用记录，复杂度 O(1)</span></span><br><span class="line"><span class="comment">// Babel 检测到尾调用时使用 while 循环执行函数体</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure>
<p>鉴于尾调用优化的在性能上的良好表现，EMCAScript 明确规定，所有 ECMAScript 的实现都应该实现“尾调用优化”。</p>
<blockquote>
<p>为了确保最后一步调用自身实现尾递归优化，就需要把函数内部用到的变量转换为函数的参数，比如上面的 total，不过这样的处理方式并不容易理解，优化方式有两种，一种是函数柯里化，另一种方式就是使用默认值参数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="对象">对象</h2><p>ES6 在编码的简洁性上做了很多工作，比如上面的箭头函数，比如下面的对象声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;;</span><br><span class="line"><span class="comment">// 相当于 obj = &#123; foo: foo &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    getSth ( x, y ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;;</span><br><span class="line">        <span class="comment">// 相当于 return &#123; x: x, y: y &#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相当于 getSth: function ( x, y ) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES2015 新增了一个 Object.is() 方法来比较两个值是否相等，主要解决两方面的问题：一是 <code>==</code> 比较时的数据类型自动转换，一是 <code>===</code> 比较时 NaN 不等于自身、<code>+0</code> 等于 <code>-0</code> 的问题。Object.is() 实现的原则是：只要两个值一样，就应该相等（Same-value equality）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span></span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>Object.assign(target, source1, source2)</code> 用于将 source1/source2… 的属性拷贝到 target 中，遇到同名属性自动覆盖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> o1 = &#123; </span><br><span class="line">    id: <span class="number">123</span>, </span><br><span class="line">    meta: &#123; </span><br><span class="line">        age: <span class="number">1</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; </span><br><span class="line">    meta: &#123;</span><br><span class="line">        age: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, o1, o2);</span><br><span class="line">target</span><br><span class="line"><span class="comment">// =&gt; &#123;"id":123,"meta":&#123;"age":2&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>到目前为止，一共有六种方法可以遍历对象的属性：</p>
<ol>
<li><code>for...in</code>，循环遍历对象自身的和集成的可枚举属性（不包含 Symbol 属性）</li>
<li><code>object.keys(obj)</code>，返回一个数组，包括自身所有可枚举属性（不含 Symbol 属性和继承属性）</li>
<li><code>Object.getOwnPropertyNames(obj)</code>，返回一个数组，包含对象自身的所有属性（不含Symbol属性，包括不可枚举属性）</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>，返回一个数组，包含对象自身的所有Symbol属性</li>
<li><code>Reflect.ownKeys(obj)</code>，返回一个数组，包含对象自身的所有属性，包括 Symbol 和不可枚举属性</li>
<li><code>Reflect.enumerate(obj)</code> 返回一个 Iterator 对象，结果与 <code>for...in</code> 相同</li>
</ol>
<p>以上六种遍历方法，都遵守同样的遍历次序：</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, b:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, a:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>
<p><code>__proto__</code> 是一个没有正式规范，被浏览器广泛支持的属性，ES6 提供了新的方法来代替对该属性的操作：<code>Object.setPrototypeOf()</code> / <code>Object.getPrototypeOf()</code> / <code>Object.create()</code>。</p>
<h2 id="Symbol">Symbol</h2><p>Symbol 是 ES2015 加入的第七种数据类型，它与 undefined/null/boolean/string/number 都是原始数据类型，Symbol 用来实现一种独一无二的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// =&gt; 'symbol'</span></span><br><span class="line"></span><br><span class="line">s1.toString();</span><br><span class="line"><span class="comment">// =&gt; 'Symbol(foo)'</span></span><br><span class="line"></span><br><span class="line">s2 === s1;</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<p>Symbol 独一无二的特性非常适合作为对象的属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    [s]: <span class="string">'Hi'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.s</span><br><span class="line"><span class="comment">// =&gt; 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>[s]</span><br><span class="line"><span class="comment">// =&gt; 'hi'</span></span><br></pre></td></tr></table></figure>
<p>在对使用 Symbol 作为属性名的对象进行遍历时，Symbol 属性不会出现在 for…in、for…of 循环中，也不会出现在 Object.keys()、Object.getOwnPropertyNames() 的返回值中。虽然如此，Symbol 并不是私有属性，可以通过 Object.getOwnPropertySymbols() 来获取指定对象的所有 Symbol 属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'baz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="number">123</span>,</span><br><span class="line">    [s2]: <span class="string">'abc'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ss = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="comment">// [ Symbol(foo), Symbol(baz) ]</span></span><br></pre></td></tr></table></figure>
<p>要获取相同的 Symbol，可以调用系统的 Symbol.for()，该方法接受一个字符串作为参数，它会检测是否存在以该字符串参数名称的 Symbol 值，找到就返回，没有就创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2;</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>上面示例中用作参数的字符串又被成为 Symbol 的 key，使用 Symbol.keyFor() 可以查看这个 key:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s);</span><br><span class="line"><span class="comment">// =&gt; 'foo'</span></span><br></pre></td></tr></table></figure>
<h2 id="Proxy_and_Reflect">Proxy and Reflect</h2><p>Proxy，顾名思义，用于代替特定对象与外界进行交互的对象，简称代理对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.xxx</span><br><span class="line"><span class="comment">// =&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">// =&gt; 'getting xxx'</span></span><br></pre></td></tr></table></figure>
<p>Proxy 的拦截操作概览：</p>
<ul>
<li>get()，拦截属性的读取</li>
<li>set()，拦截属性的设置</li>
<li>has()，拦截 propKey in proxy 操作</li>
<li>deleteProperty()，拦截 delete proxy[propKey] 操作</li>
<li>enumerate()，拦截 for ( let x in proxy ) 操作</li>
<li>ownKeys()</li>
<li>getOwnPropertyDescriptor()</li>
<li>defineProperty()</li>
<li>preventExtensions()</li>
<li>getPrototypeOf()</li>
<li>isExtensible()</li>
<li>setPrototypeOf()</li>
<li>apply()</li>
<li>construct()</li>
</ul>
<p>使用 Proxy.revocable() 可以创建一个可撤销拦截的代理对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>Reflect 对象的设计初衷：</p>
<ol>
<li>将 object 对象上明显属于语言内部的方法（Object.defineProperty）放到 Reflect 对象上</li>
<li>修改某些 Object 对象的返回结果，使其更可控，比如 Object.defineProperty() 在无法定义属性时会抛出错误，而 Reflect.defineProperty() 则会返回 false</li>
<li>让 Object 操作统一为函数行为，比如 name in obj 和 delete obj[name]，使用 Reflect.has() 和 Reflect.deleteProperty() 来执行</li>
<li>Reflect 对象的方法和 Proxy 对象的方法一一对应，两者高度统一，方便 Proxy 对象调用对应的 Reflect 方法 —— 不管 Proxy 怎么拦截和修改，总可以在 Reflect 上获取默认行为</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 操作对比 Reflect 操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, prop, attr);</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, prop, attr)) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Set_and_Map">Set and Map</h2><p>ES2015 提供的 Set 数据结构是数组的一个约束，两者的差别就在于 Set 中没有重复值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set 的参数必须实现了 iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="comment">// =&gt; [ 1, 2, "2" ]</span></span><br></pre></td></tr></table></figure>
<p>Set 实例绑定的方法可以分为两类：数据操作方法和成员遍历方法：</p>
<p><img src="/img/es2015-set-methods.png" alt="set methods"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"><span class="comment">// =&gt; [1, 2]</span></span><br><span class="line"></span><br><span class="line">set.has(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">set.delete(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line">set</span><br><span class="line"><span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>在遍历时，由于 Set 结构没有键名，只有键值，所以 keys() 和 values() 的返回值一致：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> set.keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> set.values() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> set.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; ["red","red"]</span></span><br><span class="line"><span class="comment">// =&gt; ["green","green"]</span></span><br><span class="line"><span class="comment">// =&gt; ["blue","blue"]</span></span><br></pre></td></tr></table></figure>
<p>下面是一个 Set 结构的实例，用来求取两个 Set 结构的并交差集：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...x, ...y]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>([...x].filter( x =&gt; y.has(x) ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">const</span> diffset = <span class="keyword">new</span> <span class="built_in">Set</span>([...x].filter( x =&gt; !y.has(x) ));</span><br></pre></td></tr></table></figure>
<p>WeakSet 结构和 Set 结构相似，也是不重复值的集合，差异在于两个地方：一是 WeakSet 内部的元素只能是对象，二是 WeakSet 内部的对象是弱引用，垃圾回收机制不考虑 WeakSet 中对象的引用计数。</p>
<p>由于 WeakSet 结构的对象是弱引用，随时可能消失，所以没有 size 属性，也无法进行遍历，只具有 Set 结构中的三个操作方法：add() / delete() / has()。</p>
<p>Map 结构是对现有 Object 对象的扩展，Object 中的 key 只能是字符串和 Symbol（ES2015 新增），Map 中的 key 可以是任意数据类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123; id: <span class="number">123</span> &#125;;</span><br><span class="line"></span><br><span class="line">map.set(obj, <span class="string">'hi'</span>);</span><br><span class="line">map.get(obj);</span><br><span class="line"><span class="comment">// =&gt; 'hi'</span></span><br><span class="line"></span><br><span class="line">map.has(obj);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">map.delete(obj);</span><br><span class="line">map.has(obj);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key 绑定内存地址</span></span><br><span class="line">map.set(&#123;&#125;, <span class="string">'object'</span>);</span><br><span class="line">map.get(&#123;&#125;);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>下面在 Map 初始化的时候传入一个二维数组创建 Map：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">'three'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">of</span> map.keys() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> value <span class="keyword">of</span> map.values() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; one</span></span><br><span class="line"><span class="comment">// =&gt; two</span></span><br><span class="line"><span class="comment">// =&gt; three</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [1,"one"]</span></span><br><span class="line"><span class="comment">// =&gt; [2,"two"]</span></span><br><span class="line"><span class="comment">// =&gt; [3,"three"]</span></span><br></pre></td></tr></table></figure>
<p>WeakMap 是弱引用的 Map 结构，而且 WeakMap 只能以对象作为键值，不接受其他类型的值作为键名。</p>
<h2 id="Iterator">Iterator</h2><p>现在，JS 中表示集合的数据结构包括 String、Array、Object、Map、Set、WeakMap、WeakSet 七种数据结构。Iterator 提供了一种接口，为各种不同的数据结构提供统一的接口，任何数据结构只要部署了 Iterator 结构，就可以完成遍历操作，目前，String、Array、Map 和 Set 是默认部署了该接口的数据结构，Array-like object 可以通过 Array.from() 转换为 Array 使用该接口。</p>
<p>Iterator 的作用主要有三点：</p>
<ul>
<li>为数据结构提供统一的访问接口</li>
<li>使得数据接口的成员可以按照某种次序排列</li>
<li>供 for…of 使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>凡是数据结构原生部署了 Symbol.iterator 属性，则具备 Iterator 接口，调用该接口，就可以得到一个遍历器对象。遍历器对象调用 next() 方法一次可以得到数据结构的所有成员，next() 返回一个对象，包括 value 和 done 属性。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性上，部署该属性的数据结构都被认为是可遍历的。在某些场合会自动调用遍历器接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line">[x, y] = [x, y]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// =&gt; [ "h", "e", "l", "l", "o" ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line"><span class="keyword">for</span> ... <span class="keyword">of</span></span><br><span class="line"><span class="built_in">Array</span>.from()</span><br><span class="line"><span class="built_in">Map</span>() / <span class="built_in">Set</span>() / <span class="built_in">WeakMap</span>() / <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="built_in">Promise</span>.all()</span><br><span class="line">Promis.race()</span><br><span class="line"></span><br><span class="line"><span class="comment">// yield*</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>遍历语法的发展：</p>
<ul>
<li>for 遍历，语法繁琐</li>
<li>forEach()，不能使用 break、continue、return 退出循环</li>
<li>for…in，为对象设计，遍历数组时会自动将索引转换为字符串</li>
<li>for…of，修复上述问题，可以遍历实现 iterator 接口的数据接口，不支持对普通对象的遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> key <span class="keyword">in</span> arr ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, arr[key]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; [ "0", "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ "1", "b" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ "2", "c" ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> [key, value] <span class="keyword">of</span> arr.entries() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([key, value]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// =&gt; [ 0, "a" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 1, "b" ]</span></span><br><span class="line"><span class="comment">// =&gt; [ 2, "c" ]</span></span><br></pre></td></tr></table></figure>
<h2 id="Generator">Generator</h2><p>Generator 函数是 ES2015 提供的一种异步编程解决方案。可以将 Generator 视为一个有限状态机，内部封装了多个状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数返回的遍历器对象需要调用 next 函数才会遍历到下一个内部状态，并且通过函数内部的 yield 命名挂起函数。遍历器对象 next 方法的运行逻辑：</p>
<ol>
<li>执行 next 函数，遇到 yield 命令挂起函数的执行，并且返回 yield 命令后表达式的值，作为返回的遍历器对象的 value 属性</li>
<li>继续执行 next 函数，直到遇到下一个 yield，然后挂起函数</li>
<li>如果没有再遇到 return，就运行到函数结束。函数结束时如果有 return，返回 return 后面表达式的值作为返回对象的 value 属性</li>
<li>如果没有 return 表达式，则返回对象的 value 属性为 undefined</li>
</ol>
<p><img src="/img/es2015-generator-yield.png" alt="es2015-generator-yield"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: true, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数返回的对象都部署了 Iterator 接口 [Symbol.iterator]，所以，我们可以使用 for…of 循环来遍历 Generator 函数，当返回对象的 done 属性为 true 时，循环自动中止：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> v <span class="keyword">of</span> gen() ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>Generator 返回的对象附带两个方法：throw() 和 return，用于手动抛出异常和结束 Generator 函数。</p>
<p>如果要在 Generator 函数内调用另外一个 Generator 函数，需要使用 <code>yield*</code>，实际上如果 yield 后面跟的是一个遍历器对象，都可以使用 <code>yield*</code> 来解析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 等同于 </span></span><br><span class="line">    <span class="comment">// yield 2;</span></span><br><span class="line">    <span class="comment">// yield 3;</span></span><br><span class="line">    <span class="comment">// yield 4;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果对象的某个属性是 Generator 函数，形式上有所不同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    * gen () &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = obj.gen();</span><br><span class="line"></span><br><span class="line">g.next();</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// =&gt; Object &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>前面有数组推导，Generator 函数也有推导，Generator 函数推导的优势在于它是惰性求值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bigArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ret = ( <span class="keyword">for</span> ( n <span class="keyword">of</span> bigArr() ) <span class="keyword">if</span> ( n &lt; <span class="number">10</span> ) n * n );</span><br><span class="line"></span><br><span class="line">[...ret]</span><br><span class="line"><span class="comment">// =&gt; [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]</span></span><br></pre></td></tr></table></figure>
<p>下面是使用 Generator 函数实现的一个状态机：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">        <span class="keyword">yield</span> _;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'on'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> _;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'off'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// on</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// off</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// on</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>JS 解析引擎是单线程，只能保持一个调用栈，为了保持多个任务独立的调用栈，引入了协程。Generator 函数是 ES2015 对协程的实现，但不是完整的实现，完整的协程应该可以通过任何函数实现暂停，但是只有 Generator 函数的调用者才能结束 Generator 函数。</p>
<p>如果将 Generator 函数当做协程，可以将多个需要写作的任务都写成 Generator 函数，使用 yield 命令交换控制权。</p>
<h2 id="Promise">Promise</h2><p>在 ES2015 之前，Promise 早有实现，ES2015 规范统一了 Promise 的用法。Promise 对象共有三个状态：Pending、Resolved 和 Rejected。Promise 对象的状态只能从 Pending 变为 Resolved 或者从 Pending 变为 Rejected。</p>
<p>Promise 对象存在的价值是将异步操作以同步操作的流程表达出来，避免层层嵌套的回调函数，并且提供了统一的接口，便于控制异步操作。不过，Promise 也存在一些缺点：</p>
<ul>
<li>创建后立即执行，无法中途取消</li>
<li>如果不设置回调函数，无法抛出内部错误</li>
<li>处于 Pending 状态时，无法获得具体状态（刚刚开始还是即将完成）</li>
</ul>
<p>ES2015 规定，Promise 对象是一个构造函数，用于生成 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( (resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>, <span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then((value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1000ms 后</span></span><br><span class="line"><span class="comment">// =&gt; 'done'</span></span><br></pre></td></tr></table></figure>
<p>Promise 实例具有两个方法：then(resolved，rejected) 和 catch()。catch() 相当于是 <code>.them(null, rejected)</code> 的缩写，用于指定发生错误时的回调函数。</p>
<p>Promise 对象本身还有四个方法：all()、race()、resolve()、reject()。Promise.all() 方法接收包含多个 Promise 实例的一个数组，打包封装成一个 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line"><span class="comment">// p 的状态取决于 p1、p2、p3</span></span><br><span class="line"><span class="comment">// p1、p2、p3 全部 resolved 时，p resolved</span></span><br><span class="line"><span class="comment">// p1、p2、p3 有一个 rejected，p rejected</span></span><br></pre></td></tr></table></figure>
<p>Promise.race() 同样打包多个返回一个 Promise 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line"><span class="comment">// 与 Promise.all() 的不同之处在于，</span></span><br><span class="line"><span class="comment">// p 的状态取决于 p1、p2、p3 中状态最先发生变化的那个</span></span><br></pre></td></tr></table></figure>
<p>Promise.resolve() 方法用于将现有对象转换为 Promise 对象；Promise.reject() 方法返回一个 Promise 实例，该实例的默认状态就是 rejected。</p>
<p>ES2015 的 Promise API 并不是很多，可以根据自己的开发需要部署特定的方法，比如我们可以部署两个比较常用的方法：done() 和 finally()。Promise 实例以 then() 或 catch() 方法作为结尾方法时，如果结尾方法抛出错误，是有可能无法捕捉到的，所以可以实现一个 done 方法置于回调链的结尾，保证抛出的任何方法都能被捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">            setTimeout(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>finally() 方法用于指定回调链的最终操作，与 done 方法的区别在于，它接受一个普通的回调函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器使用 Promise 处理请求，使用 finally 关掉服务器</span></span><br><span class="line">server.listen(<span class="number">0</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    .finally(server.stop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(() =&gt; &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Async">Async</h2><p>我们有回调函数、Promise 以及 Generator 这三种异步编程方式了，为什么在此之外还要提供 Async 函数？因为它们本身还有一些问题：</p>
<ul>
<li>回调函数的最大问题是回调嵌套</li>
<li>Promise 解决了回调嵌套的问题，但是被 then 方法包装后的代码存在冗余问题，语义和理解性较差</li>
<li>Generator 的代码写起来非常像同步代码，如果去除 yield 命令，简直就是同步代码，但是它失去了 Promise 可以自动执行的特性，所以它的缺点就是需要创建一个自动执行函数（Thunk 函数），或者使用三方模块（co），总之要驱动它自执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callback Hell</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> finalCallback </span>) </span>&#123;</span><br><span class="line">    request.get(url1, <span class="function"><span class="keyword">function</span>(<span class="params">err1, res1</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err1) <span class="keyword">return</span> finalCallback(err1);</span><br><span class="line">        </span><br><span class="line">        request.post(url2, <span class="function"><span class="keyword">function</span>(<span class="params">err2, res2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err2) <span class="keyword">return</span> finalCallback(err2);</span><br><span class="line">            </span><br><span class="line">            request.put(url3, <span class="function"><span class="keyword">function</span>(<span class="params">err3, res3</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err3) <span class="keyword">return</span> finalCallback(err3);</span><br><span class="line">                </span><br><span class="line">                request.del(url4, <span class="function"><span class="keyword">function</span>(<span class="params">err4, res4</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err4) <span class="keyword">return</span> finalCallback(err4);</span><br><span class="line">                    </span><br><span class="line">                    finalCallback(<span class="literal">null</span>, <span class="string">"whew all done"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request.getAsync(url1)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res1</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.postAsync(url2);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.putAsync(url3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res3</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> request.delAsync(url4);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">res4</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator</span></span><br><span class="line"><span class="keyword">import</span> co <span class="keyword">from</span> <span class="string">'co'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> request.getAsync(url1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> request.getAsync(url2);</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">yield</span> request.getAsync(url3);</span><br><span class="line">    <span class="keyword">const</span> res4 = <span class="keyword">yield</span> request.getAsync(url4);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> request.getAsync(url1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> request.getAsync(url2);</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">await</span> request.getAsync(url3);</span><br><span class="line">    <span class="keyword">const</span> res4 = <span class="keyword">await</span> request.getAsync(url4);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"whew all done"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器的惰性求值往往是将参数放入临时函数中实现的，在求值时调用这个临时函数，这个临时函数叫做 Thunk 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span> (<span class="params"> v </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp( x + <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span> (<span class="params"> v </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thunk() + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JS 中，Thunk 函数要做的是将多参数函数转换为单参数函数，且只接受回调函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>任何函数，只要参数是回调函数，就能写成 Thunk 函数的形式，下面是一个简单的 Thunk 函数转换器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            args.push(callback);</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之所以要提 Thunk 函数，是因为它可以驱动 Generator 函数自执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>ES7 提供了 Async 函数，它相当于是 Generator 函数的语法糖。下面使用两种函数读取文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">cosnt readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 函数</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async</span></span><br><span class="line">cosnt asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    cosnt f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">    cosnt f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，两者在语法上有所不同，但这不是最重要的，重要的是一下三点：</p>
<ol>
<li>Async 函数内置自动执行器，而 Generator 需要自己写自动执行函数或者使用第三方库，比如 co</li>
<li>更广的适应性，co 模块约定 yield 后面只能是 Thunk 函数或者是 Promise 对象，而 Async 函数的 await 后面可以使用 Promise 对象或原始值类型（此时等于同步操作）</li>
<li>Async 的返回值是 Promise 对象，这比 Generator 返回的 Iterator 对象要更方便一些，可以使用 then() 来制定下一步的操作逻辑</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&gt; &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>await 命令后面跟着一个 Promise 对象，运行结果可能是 rejected，需要使用 try…catch 来捕获异常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> P();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> P().catch( err =&gt; <span class="built_in">console</span>.log(err) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class">Class</h2><p>JS 传统的原型继承等方式和其他语言差异较大，造成了一定的学习难度。ES2015 提供了和其他语言相仿的面向对象语法，引入了 Class 的概念，用作对象的模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor( x, y ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`( <span class="subst">$&#123;this.x&#125;</span>, <span class="subst">$&#123;this.y&#125;</span> )`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">p.getInfo();</span><br><span class="line"><span class="comment">// =&gt; ( 3, 4 )</span></span><br></pre></td></tr></table></figure>
<p>上例中的 constructor 是构造方法，this 代表实例对象。constructor 方法是类的默认方法，使用 new 命令生成对象实例时，自动调用盖房，如果没有显示定义该方法，就会自动添加一个空的 constructor 方法，constructor 方法默认返回类的实例对象，该返回值完全是可以修改的。</p>
<p>Class 之间使用 extends 关键字实现继承，这种写法比 ES5 要简洁很多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor( x, y ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`( <span class="subst">$&#123;this.x&#125;</span>, <span class="subst">$&#123;this.y&#125;</span> )`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor ( x, y, color ) &#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">super</span>.getInfo() + <span class="string">` is <span class="subst">$&#123;this.color&#125;</span>`</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="keyword">new</span> ColorPoint( <span class="number">3</span>, <span class="number">4</span>, <span class="string">'red'</span> );</span><br><span class="line">cp.getInfo();</span><br><span class="line"><span class="comment">// =&gt; ( 3, 4 ) is red</span></span><br></pre></td></tr></table></figure>
<p>在继承类的构造函数中出现了 super()，它指代父类的 this 对象。子类必须在 constructor 中调用 super 方法，否则新建实例会报错，这是因为子类没有自己的 this 对象，而是使用继承自父类的 this 对象，一切都是基于对这个 this 的加工处理，如果不调用 super()，就得不到 this 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cp = <span class="keyword">new</span> ColorPoint();</span><br><span class="line"><span class="comment">// =&gt; Babel: 'this' is not allowed before super()</span></span><br><span class="line"><span class="comment">// =&gt; Firefox: ReferenceError: |this| used uninitialized in ColorPoint class constructor</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES5 的原型继承，实质是先创造子类的实例对象 this，然后再讲父类的方法添加到 this 上。ES6 的继承机制则是相反的，实质是先创造父类的实例对象 this（调用 super() ），然后在用子类的构造函数修改 this。</p>
</blockquote>
<p>类相当于实例的原型，类中定义的方法都会被实例所继承，如果不想让实例继承继承某个方法，可以通过 static 关键字设置类的静态方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    static getInfo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">Foo.getInfo();</span><br><span class="line"><span class="comment">// =&gt; 'foo'</span></span><br><span class="line">f.getInfo();</span><br><span class="line"><span class="comment">// =&gt; TypeError: f.getInfo is not a function</span></span><br></pre></td></tr></table></figure>
<p>ES2015 规定类内部只有静态方法，没有静态属性，ES2016 有一个静态属性的提案，目前 Babel 已经支持：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    position = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    static color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new 是从类生成实例的命令，ES2015 的 new 命令增加了一个 <code>new.target</code> 的属性，表示 new 引用的构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">new</span>.target === Point ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'right'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'wrong'</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line"><span class="comment">// =&gt; right</span></span><br><span class="line">Point.call(p, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// =&gt; Babel: wrong</span></span><br><span class="line"><span class="comment">// =&gt; Firefox: TypeError: class constructors must be invoked with |new|</span></span><br></pre></td></tr></table></figure>
<p>在子类继承父类时，new.target 返回的是子类，利用这个特点，可以写出不能独立使用、必须继承后才能使用的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Shape();</span><br><span class="line"><span class="comment">// =&gt; Error: 本类不能实例化</span></span><br></pre></td></tr></table></figure>
<h2 id="Decorator">Decorator</h2><p>ES2016 的 Decorator 相当于设计模式中的装饰模式，所以下文就以装饰器来指代 Decorator。与上面提到的 Proxy（代理者，代理模式）不同，装饰器的核心作用是增强被装饰者的功能，而代理对象的作用是管理外界对被代理者的访问权限。装饰器只能用于类和类的方法，不能用于函数，因为编译时存在函数提升。修饰漆对类的行为的改变，是代码编译时发生的，而不是运行时，这意味着，修饰漆能在编译阶段运行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLS</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> CLS();</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>
<p>装饰器函数可以接收三个参数：目标函数、属性名和属性的描述对象。上例代码通过装饰器 mixins，为指定类添加了指定的方法。装饰器的一个实际应用就是注释:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">'core-decorators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> <span class="keyword">extends</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    entree = <span class="string">'steak'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">'salmon'</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure>
<p>除了注释功能，装饰器还能用作类型检查，长期来看，它将成为 JavaScript 代码静态分析的重要工具。</p>
<h2 id="Module">Module</h2><p>在 ES2015 之前，社区中主要有 CommonJS 和 AMD 两种模块加载方式，ES2015 提出了自己的模块功能，其设计思想是尽量的静态化，在编译时确定模块的依赖关系、输入输出变量。</p>
<p>ES2015 module 主要由两个命令组成：<code>export</code> 和 <code>import</code>。export 用于提供对外接口，import 用于引用外部模块。每个模块都是独立的文件，外部无法直接获取模块文件的变量，只能通过 export 对外输出变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数和类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>export 定义了外部接口之后，可以使用 import 命令在其他模块中加载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 as 命令重命名引入的变量</span></span><br><span class="line"><span class="comment">// import 语法存在变量提升，最好置于文件顶部</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar <span class="keyword">as</span> baz &#125; <span class="keyword">from</span> <span class="string">'./modulename'</span>;</span><br></pre></td></tr></table></figure>
<p>从上面 import 的示例中，我们发现当需要引入外部模块时，必须明确知道模块内部的变量名，这是非常不友好的方式。<code>export default</code> 命令就是为了解决这个问题存在的，其作用是为模块指定默认的输出内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 'export-default.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'import-default.js'</span></span><br><span class="line">immport customName from <span class="string">'./export-default.js'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="建议使用的特性">建议使用的特性</h2><h6 id="参考资料">参考资料</h6><ul>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript6 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="external">MDN JavaScript</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2015/mac-tool-kit/" class="prev">PRVE</a><a href="/2015/求值策略/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://pinggod.com">Sean Sun</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>