<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React 组件的生命周期 · PINGGOD</title><meta name="description" content="React 组件的生命周期 - Sean Sun"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">React 组件的生命周期</h1><div class="post-meta"><div class="post-time">Nov 23, 2015</div></div><div class="post-content"><p>在 React 所实践的组件化中，非常重要的一点就是组件的生命周期，简而言之是组件的挂载、更新和卸载流程。下图详细列述了 React 组件在整个生命周期中所涉及的方法和行为：</p>
<p><img src="/img/react-lifecycle.png" alt="React 组件的生命周期"></p>
<a id="more"></a>
<p>在组件实例创建之初，会依序调用 <code>getDefaultProps()</code>、<code>getInitialState()</code> 方法初始化数据。在 ES6 中，可以简写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">static defaultProps = &#123;</span><br><span class="line">    key: value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">state = &#123;</span><br><span class="line">    key: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于从父组件传递来的 props，React 提供了 <code>propTypes</code> 配置对象来校验数据类型或格式，常用类型如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line">React.PropTypes.bool                              </span><br><span class="line"><span class="comment">// 数值</span></span><br><span class="line">React.PropTypes.number                            </span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">React.PropTypes.string                            </span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">React.PropTypes.func                              </span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">React.PropTypes.array                             </span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">React.PropTypes.object                            </span><br><span class="line"><span class="comment">// 数值、字符串、DOM 元素及包含这些类型的数组</span></span><br><span class="line">React.PropTypes.node                              </span><br><span class="line"><span class="comment">// React 元素</span></span><br><span class="line">React.PropTypes.element                           </span><br><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line">React.PropTypes.instanceOf(Message)               </span><br><span class="line"><span class="comment">// 数组包含的值之一</span></span><br><span class="line">React.PropTypes.oneOf([<span class="string">'News'</span> <span class="string">'Photos'</span>])          </span><br><span class="line"><span class="comment">// 数组包含的类型之一</span></span><br><span class="line">React.PropTypes.oneOfType([                       </span><br><span class="line">    React.PropTypes.string,         </span><br><span class="line">    React.PropTypes.number,         </span><br><span class="line">    React.PropTypes.instanceOf(Message)                                  </span><br><span class="line">])                                               </span><br><span class="line"><span class="comment">// 数值数组</span></span><br><span class="line">React.PropTypes.arrayOf(React.PropTypes.number)   </span><br><span class="line"><span class="comment">// 对象的属性值为数值类型</span></span><br><span class="line">React.PropTypes.objectOf(React.PropTypes.number)  </span><br><span class="line"><span class="comment">// 组合类型</span></span><br><span class="line">React.PropTypes.shape(&#123;                           </span><br><span class="line">    React.PropTypes.string                                   </span><br><span class="line">    React.PropTypes.number                                   </span><br><span class="line">&#125;)                                                 </span><br><span class="line"><span class="comment">// 任何类型，必填</span></span><br><span class="line">React.PropTypes.any.isRequired                    </span><br><span class="line"><span class="comment">// 自定义规则</span></span><br><span class="line">customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props propName componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Validation failed!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mount">mount</h2><p>在组件的挂载过程中，会依次调用 componentWillMount()、render() 和 componentDidMount()。挂载完成后，<code>componentWillMount()</code> 和 <code>componentDidMount()</code> 将不会再被触发，<code>render()</code> 则会根据 props 和 state 的变化多次执行。</p>
<p>在 componentDidMount() 调用之前，只能得到由 render() 返回的虚拟 DOM；在该方法执行时，真实 DOM 的渲染已经完成，此时，可以通过 React 内建的 <code>getDOMNode()</code> 访问真实的 DOM。</p>
<h2 id="update">update</h2><p>挂载结束后，组件处于监听状态，监听 props 和 state 的变化。props 和 state 的差异在于：state 用于配置组件内的状态，props 则用于在组件间传递数据。</p>
<p>在实际开发中，这一阶段调用的核心都是围绕 state 展开的。state changed 之后，系统会立即调用 <code>boolean shouldComponentUpdate(object nextProps, object nextState)</code> 方法来决定是否重新渲染页面。当遭遇性能瓶颈时，适当地通过该方法控制页面渲染的频率是为提升性能不二法门。</p>
<p>当 props changed 时，系统会立即调用 <code>componentWillReciveProps(object nextProps)</code> 方法。该方法常被用来执行 props -&gt; state 的更新，继而触发整个页面的渲染。</p>
<p>在这一阶段重新渲染页面所需要的同样是 will -&gt; render -&gt; did 三个方法。不同之处在于，此处的 did 和 will 附加了 props 和 state 信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentWillUpdate(object nextProps, object nextState) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(object prevProps, object prevState) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unmount">unmount</h2><p>组件卸载前会执行 <code>componentWillUnmount()</code>，用于清理 <code>componentDidMount()</code> 之后创建的组件。此外，对于组件生命周期内累积的监听事件和定时器，也应当在该方法内执行解绑、清除操作。</p>
<h2 id="组件化">组件化</h2><p>目前组内正在构建一套 React 基础组件，方法和思路与 AlloyTeam <a href="http://www.alloyteam.com/2015/11/we-will-be-componentized-web-long-text/" target="_blank" rel="external">《致我们终将组件化的 Web》</a>一文类似。其中，作者对组件提出了五点要求，如下图所示，值得参考：</p>
<p><img src="/img/react-component.png" alt="组件化的要求"></p>
<p>其中“规范化的接口”，也可更改为可管理的生命周期。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/React-组件间的消息传递/" class="prev">PRVE</a><a href="/2015/Sass/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://pinggod.com">Sean Sun</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>